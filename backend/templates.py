from groq import Groq
from langchain.prompts import ChatPromptTemplate
from langchain.schema import StrOutputParser
from langchain.output_parsers import PydanticOutputParser
from pydantic import BaseModel, Field
from typing import Optional
import os
from dotenv import load_dotenv
import logging

load_dotenv()

# Initialize the Grok client
GROK_API_KEY = os.getenv('GROK_API_KEY')
client = Groq(api_key=GROK_API_KEY)

class SocialMediaResponse(BaseModel):
    """
    Structured data model for social media responses
    
    Provides a consistent, validated structure for AI-generated responses
    Key Components:
    - Response text
    - Optional business mention
    - Confidence scoring
    """
    # Main response text (required field)
    response_text: str = Field(
        description="The main response text generated by the AI"
    )
    
    # Optional business mention (can be None)
    business_mention: Optional[str] = Field(
        default=None, 
        description="How the business was naturally mentioned in the response"
    )
    
    # Confidence score to evaluate response quality
    confidence_score: float = Field(
        description="Confidence level of the response relevance (0-1 scale)"
    )

# Create a global parser for structured output parsing
parser = PydanticOutputParser(pydantic_object=SocialMediaResponse)

def create_social_response_chain():
    """
    Creates a reusable chain for generating social media responses using the Grok API
    
    Key Functionality:
    - Configures a structured prompt template
    - Sets up a processing chain for response generation with Grok API
    
    Returns:
        LangChain processing chain for social media responses
    """
    
    # Create a comprehensive prompt template with detailed instructions
    # Uses a two-part message structure:
    # 1. System message: Overall behavior guidelines
    # 2. Human message: Specific context for response generation
    prompt = ChatPromptTemplate.from_messages([
        ("system", """You are a helpful social media expert who provides valuable responses while naturally 
        incorporating business mentions. Focus on:
        1. Authenticity and value-first approach
        2. Natural conversation flow
        3. Mentioning businesses in a natural non-intrusive way
        4. Maintaining appropriate platform tone (Reddit: casual, LinkedIn: professional, Twitter: concise)
        
        If the business mention feels forced, prioritize providing valuable information instead."""),
        ("human", """Context:
        Platform: {platform}
        Post: {post_text}
        
        Business Info:
        Name: {business_name}
        Description: {business_description}
        Website: {website_link}
        
        Generate a helpful response that prioritizes value while naturally mentioning the business smoothly and not like a promotional bot.
        {format_instructions}""")
    ])

    # Define a function to call the Grok API
    def grok_llm(input_dict):
        try:
            # Format the prompt using the input dictionary
            formatted_prompt = prompt.format(**input_dict)
            messages = [
                {"role": "system", "content": formatted_prompt.messages[0].content},
                {"role": "user", "content": formatted_prompt.messages[1].content}
            ]
            response = client.chat.completions.create(
                model="mixtral-8x7b-32768",  # Use the appropriate Grok model
                messages=messages,
                max_tokens=150,
                temperature=0.7  # Balanced between deterministic and creative responses
            )
            return response.choices[0].message.content
        except Exception as e:
            logging.error(f"Error calling Grok API: {str(e)}")
            return f"Error generating response: {str(e)}"

    # Create the processing chain
    # Combines: 
    # 1. Prompt Template
    # 2. Grok API call
    # 3. Output Parser
    chain = (
        prompt   # Structured prompt
        | grok_llm  # Grok API call
        | StrOutputParser()  # Parse the raw string output
        | parser  # Structured output parsing
    )
    
    return chain

def generate_social_reply(
    platform: str,
    post_text: str,
    business_name: str,
    business_description: str,
    website_link: str
) -> str:
    """
    Generic social media response generator
    
    Generates a platform-agnostic response with business context
    
    Args:
        platform (str): Social media platform (reddit, twitter, linkedin)
        post_text (str): Original post content
        business_name (str): Name of the business
        business_description (str): Business description
        website_link (str): Business website URL
    
    Returns:
        str: Generated response text
    """
    
    # Create the response generation chain
    chain = create_social_response_chain()
    
    # Generate response by invoking the chain with comprehensive context
    try:
        response = chain.invoke({
            "platform": platform,
            "post_text": post_text,
            "business_name": business_name,
            "business_description": business_description,
            "website_link": website_link,
            # Include format instructions for structured output
            "format_instructions": parser.get_format_instructions()
        })
        # Commented out confidence filtering - can be uncommented for stricter response selection
        # if response.confidence_score < 0.7:
        #     return response.response_text
        return response.response_text
    except Exception as e:
        logging.error(f"Error generating social reply: {str(e)}")
        return f"Hey, have you checked out {business_name}? It might help with what you're looking for! {website_link}"

# Platform-specific wrapper functions for easy integration
# Abstracts platform-specific post structure while using generic response generator

def generate_reddit_reply(post, business_name, business_description, website_link):
    """
    Generate a Reddit-specific reply
    Combines post title and body for context
    """
    return generate_social_reply(
        "reddit",
        f"{post.title}\n\n{post.selftext[:5000]}",  # Limit body text length
        business_name,
        business_description,
        website_link
    )

def generate_twitter_reply(tweet, business_name, business_description, website_link):
    """
    Generate a Twitter-specific reply
    Uses tweet text directly
    """
    return generate_social_reply(
        "twitter",
        tweet.get('text', ''),  # Safely get tweet text
        business_name,
        business_description,
        website_link
    )

def generate_linkedin_reply(post, business_name, business_description, website_link):
    """
    Generate a LinkedIn-specific reply
    Uses post text directly
    """
    return generate_social_reply(
        "linkedin",
        post.get('text', ''),  # Safely get post text
        business_name,
        business_description,
        website_link
    )